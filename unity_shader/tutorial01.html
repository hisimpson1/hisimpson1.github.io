<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<!--URP simple code-->
  
  <style type="text/css">table {
        line-height:160%; FONT-SIZE: 11pt; MARGIN: 0px; FONT-FAMILY: 맑은 고딕, 바탕, Courier New, Courier
}
  </style>
  
  <style type="text/css">div {
        line-height:130%; font-family:돋움체; font-size:10pt; color:black; background-color:white; padding:0pt; border-width:1pt; border-color:black; border-style:solid
}
  </style>
  
  <style type="text/css">
	li {
          margin: 10px 0;
        }

        li:last-child {
           margin-bottom: 0;
        }
  </style>
  
  <meta name="GENERATOR" content="Namo WebEditor v6.0">

  
  <meta charset="UTF-8">
  <title>URP simple code</title>

  
<!-- Google tag (gtag.js) -->
  
  <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Z0ZXNX5CYQ"></script>
  
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-Z0ZXNX5CYQ');
  </script>
</head><body>
<h1>URP simple code<br>
</h1>

<table border="0" width="700">

  <tbody>
    <tr>
      <td>URP로 셰이더 코드를 작성할려면 가져올수 있는 기본 코드를 확인해보자.<br>
      <a href="https://docs.unity3d.com/kr/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-shaders-urp-basic-unlit-structure.html">https://docs.unity3d.com/kr/Packages/com.unity.render-pipelines.universal@15.0/manual/writing-shaders-urp-basic-unlit-structure.html</a><br>
      <br>
      <div><span style="color: rgb(0, 153, 0);">// 이 셰이더는 코드에 사전 정의된 컬러로 메시 모양을 채웁니다.</span><br>
Shader "Example/URPUnlitShaderBasic"<br>
{<br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp; // Unity 셰이더의 프로퍼티 블록입니다. 이 예제에서 이 블록은 비어 있습니다.</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp; // 출력 컬러가 프래그먼트 셰이더 코드에 사전 정의되어 있기 때문입니다.</span><br>
&nbsp;&nbsp;&nbsp; Properties<br>
&nbsp;&nbsp;&nbsp; { }<br>
      <br>
&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 셰이더 코드가 포함된 서브셰이더 블록입니다.</span><br>
&nbsp;&nbsp;&nbsp; SubShader<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 서브셰이더 태그는 서브셰이더 블록 또는 패스가 실행되는 시기와</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 조건을 정의합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalPipeline" }<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pass<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// HLSL 코드 블록입니다. Unity SRP는 HLSL 언어를 사용합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HLSLPROGRAM<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 이 줄은 버텍스 셰이더의 이름을 정의합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma vertex vert<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 이 줄은 프래그먼트 셰이더의 이름을 정의합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma fragment frag<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// Core.hlsl 파일에는 자주 사용되는 HLSL 매크로 및 함수에 대한 정의가 포함되어 있으며,</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 다른 HLSL 파일(예: Common.hlsl, SpaceTransforms.hlsl 등)에 대한</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // #include 레퍼런스도 포함되어 있습니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#include
"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 구조 정의는 포함하는 변수를 정의합니다.</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 이 예제에서는 버텍스 셰이더의 입력 구조로 Attributes</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 구조를 사용합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Attributes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// positionOS 변수에는 오브젝트 공간의 버텍스 포지션이</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 포함됩니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
float4 positionOS&nbsp;&nbsp; : POSITION;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct Varyings<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 이 구조체의 포지션에는 SV_POSITION 시맨틱이 있어야 합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
float4 positionHCS&nbsp; : SV_POSITION;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// Varyings 구조에 정의된 프로퍼티가 있는 버텍스 셰이더</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 정의입니다. vert 함수의 타입은 반환하는 타입(구조체)과</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 일치해야 합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Varyings vert(Attributes IN)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 출력 오브젝트(OUT)를 Varyings 구조체로 선언합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Varyings OUT;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// TransformObjectToHClip 함수는 버텍스 포지션을 오브젝트 공간에서</span><br style="color: rgb(0, 153, 0);">
      <span style="color: rgb(0, 153, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 균일한 클립 공간으로 변환합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
OUT.positionHCS = TransformObjectToHClip(IN.positionOS.xyz);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 출력을 반환합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return OUT;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 프래그먼트 셰이더 정의입니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; half4 frag() : SV_Target<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// 컬러 변수를 정의하고 반환합니다.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
half4 customColor = half4(0.5, 0, 0, 1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return customColor;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ENDHLSL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; }<br>
}<br>
      </div>
      <br>
결과)<br>
메시에 빨간색을 표시 합니다.<br>
      <br>
      <span style="color: rgb(51, 51, 255); font-weight: bold;">Input, Output을 사용하지 않고 “Attributes”와 “Varyings” 변수를 사용할까요?</span><br>
      <br>
그래픽스 교재들에서 사용해온 관행에서 비롯 된것입니다.<br>
OpenGL을비롯하여 심지어 DirectX 문서에도 있습니다.<br>
      <br>
Vertex Attribute<br>
OpenGL 명세에서는 정점 입력을 Vertex Attributes라고 부릅니다.<br>
      <br>
Varying<br>
OpenGL 문서, 교재에서 다음 표현을 씁니다.<br>
“this varying is interpolated…”<br>
      <br>
DirectX 문서에서는 VS → PS로 전달되는 데이터를 다음과 같이 표현 합니다.<br>
"interpolated values varying data"<br>
      <br>
결론<br>
Attributes&nbsp; <span style="color: rgb(0, 153, 0);">// “정점 고유 데이터”</span><br>
Varyings&nbsp;&nbsp; <span style="color: rgb(0, 153, 0);">// “보간되어 다음 단계로 가는 데이터”</span><br style="color: rgb(0, 153, 0);">
      <br>
      <br>
<br>
      <br>
      </td>
    </tr>
  </tbody>
</table>

<p>&nbsp;</p>

<p>&nbsp;</p>

<script language="JavaScript">

var images = document.getElementsByTagName('img'); 

for(var i = 0; i < images.length; i++) { 
    images[i].style.width = images[i].width/2 + 'px';
    images[i].style.height = images[i].height/2 + 'px';
    images[i].addEventListener("click", ChangeImageSize.bind(images[i]), false);
    images[i].setAttribute('data-imageSize', '0.5');
}

function ChangeImageSize(){
    imageSize = this.getAttribute('data-imageSize')

    width = this.width;
    height = this.height;

    if(imageSize == '1') 
    {
	this.setAttribute('data-imageSize', '0.5');
        width =  width/2;
        height = height/2;      
    }
    else 
    {
	this.setAttribute('data-imageSize', '1');
        width = width*2;
        height = height*2;
    }

    this.style.width = width + 'px';
    this.style.height = height + 'px';
}

</script>
</body></html>